### TinyWebServer

Linux 下 C++ 轻量级 Web 服务器.

* 使用 线程池 + 非阻塞 socket + epoll(ET & LT) + 事件处理 (Reactor + 模拟 Proactor) 的并发模型
* 使用状态机解析 HTTP 请求报文，支持解析 GET 和 POST 请求
* 服务器连接数据库，实现 web 端用户注册、登录功能，可以请求服务器的图片和视频文件
* 实现 同步 / 异步 日志系统，记录服务器运行状态.
* 使用 Webbench 进行压力测试

#### 数据流动过程

客户端发送http报文 --> 存储至读缓冲区 --> 解析http报文，将响应报文存储至写缓冲区 --> 
交回给客户端

reactor模式下: 上述过程均由线程池中的子线程完成，主线程只需要监听事件即可.
proactor模式下: 子线程只需要完成解析报文的步骤，其他步骤由主线程处理.

#### 命名规范

类: 驼峰类型，开头大写
其他: 下滑线 (对象名，函数名)

#### ？

每个线程对应一个任务，而不是一个套接字？

mmap()的使用？

半同步半异步工作模式在代码是如何体现的？
(IO异步，HTTP请求处理同步)

Reactor/Proactor是如何体现的？

在工作线程中，若为Reactor,则工作线程首先需要读取/写入内容，接着处理http请求;
而在Proactor下时直接处理http请求。

条件变量在系统中是如何使用的？



### 面试问题

#### 线程池相关

* 线程的同步机制有哪些？

1. 互斥锁Mutex, 每次只有一个线程能够获得锁。如果一个线程已经加锁，其他线程会被阻塞，直到该线程释放锁。

2. 读写锁：一种特殊的互斥锁，允许多个线程同时读，但若有线程写，则所有其他线程被阻塞。

3. 条件变量：允许线程在某些条件下阻塞，直到某个条件被满足时才被唤醒。常用于生产者-消费者模型。

4. 信号量，计数器，用于控制对共享资源的访问。

5. 原子操作：不可分隔的操作，适用于需要保证操作的完整性而不需要使用锁的场景。std::atomic，例如简单的++, --.

* 线程池中的工作线程是一直等待吗？

是的，工作线程处于等待或运行状态。通过信号量的wait()操作，线程处于阻塞状态，不会占用CPU资源。当有任务被加入工作队列时，进程被唤醒，取出任务执行，执行完毕后再次进入阻塞等待状态。

线程池通过“等待+唤醒”机制，实现了高效的并发任务处理，同时避免 CPU 资源浪费。

* 线程池工作线程处理完一个任务后的状态是什么？

线程处理完一个任务后，不会退出，而是回到等待状态，继续监听新的任务。在处理完 http 的请求后，工作进程仍然处于 while(true) 循环，通过信号量的 wait()操作进入再次进入阻塞状态。

线程池中的进程不会主动退出，直到程序结束，线程池被销毁（析构函数~ThreadPool()）


#### HTTP报文解析相关

* 为什么使用状态机？

使用状态机是为了高效、可靠的解析 HTTP 请求，而不会因为不完整的数据包导致
解析失败或者阻塞.

HTTP请求通过TCP传输，而TCP是流式协议，数据可能会分多次到达。

例如一次 recv() 可能值接收到部分HTTP头部，或者完整头部但没有接收到报文主体,
如果世界使用字符串匹配或者一次性读取完整请求的方式，可能会:
* 数据不完整，导致解析失败
* 阻塞等待完整数据，影响服务器性能
* 浪费 CPU 资源，CPU需要不断轮询检查数据是否完整

状态机作用：
* 状态机能处理数据分段到达的情况，即使一次 recv() 只接收到部分数据，也能继续解析，不丢失状态
* 减少CPU轮询：不会一直检查是否接收到完整数据，而是等 epoll_wait 触发 EPOLLIN 事件时继续解析
* 可以在任意位置中断解析，并在下一次数据到来时继续，不会因为数据丢失而导致解析失败

状态机能够保证对不完整的数据进行解析的核心原理在于 “分阶段解析 + 维护解析状态”，
可以保存当前解析的进度，在下一次数据到达时从上次中断的地方继续解析，而不是每次都
从头开始。

* HTTPS协议为什么安全？

HTTPS在HTTP的基础上加入了 SSL/TLS 加密协议。HTTPS通过加密、认证和完整数据校验
保护数据的传输安全，防止常见的网络攻击，例如窃听、中间人攻击和篡改。

* GET 和 POST 的区别

用途：
* GET: 用于获取数据，不会对服务器资源产生影响（幂等）
* POST：用于提交数据，通常会修改服务器的资源（非幂等）

GET常用于：获取网页内容GET /index.html; 查询数据 /search?q=hello

POST适用于：提交表单数据；上传文件；发送敏感信息（如密码）

参数传递方式：
* GET： URL传参，放在?key=value形式的查询字符串中
* POST: 请求体body传参

安全性：
GET： 不安全，参数暴露在URL中，可被缓存和记录
POST：相对安全

幂等性：
* GET：幂等，多次请求结果相同
* POST：非幂等，多次请求可能导致不同结果

#### 数据库登录注册相关

* 用户登录过程:

Web初始化时，首先获取数据库连接池中的一条连接，通过该连接获取用户表中的所有数据，
每一条记录为用户名和密码，存储在一个map结构中(热启动)。
在用户登录时从map中搜索是否有该用户。

* 你这个保存状态了吗？如果要保存，你会怎么做

可以使用Cookie和Session保存用户的状态.

Cookie存储在客户端--游览器中，Session存储在服务器中。服务器在响应头设置Cookie，游览器获取响应后存储Cookie. 同时服务器生成一个唯一的Session ID存储在数据库中，用于存储用户信息。游览器发送请求时包含带有Session ID的Cookie，服务器解析Cookie中的Session ID，读取对应的用户数据(如果有的话).

